var0 :
"mov eax , 106"
var0 : \n jmp short var1
var0 : \n jmp var1
var0 : \n jmp var1
var0 : \n jmp short var1
var0 : \n jmp short var1
var0 : \n jmp short var1
var0 : \n jmp short var1
var0 : \n jmp short var1
var0 : \n jmp short var1
var0 : \n jmp short stage
"add al , var0"
"add al , 3"
"add byte [var1] , var0"
"add byte [var1] , var0"
"add var0 , 4 \n jnz decode"
"add var1 , var0"
"add var1 , var0"
"add var0 , 2"
"add var0 , 2"
call var0
call decoder
call var0
call var0
var0 : \n call [esp]
var0 :
var0 :
var0 : \n call [esp]
var0 : \n call [esp]
var0 : \n call [esp]
var0 : \n call [esp] \n pop var3
"mov eax , 106"
"mov eax , 106"
var0 : \n call [esp]
var0 : \n call [esp]
var0 : \n call [esp]
var0 : \n call [esp]
var0 : \n call [esp]
var0 :
"cmp al , cl \n jne short decode \n jmp shellcode"
"cmp var0 , var1 \n je shellcode"
"cmp var1 , var2 \n je var0 \n jmp var3"
"cmp BYTE [var0] , var1 \n je shellcode"
"cmp byte [esi] , var1 \n jne var0"
"cmp dword var2 , var3 \n je short var0"
var0 : \n inc var1 \n inc var1
cycle :
dec al \n jz shellcode
"sub var0 , 1"
"mov eax , 106"
"mov eax , 106"
decode :
"mov eax , 106"
"mov eax , 106"
"mov eax , 106"
decode
"var0 : \n cmp byte [esi] , var2 \n jl var1 \n sub byte [esi] , var2 \n jmp var4"
decode [var0]
var0 : \n not byte [var1]
"var0 : \n sub byte [esi] , 13"
"var0 : \n xor byte [var1] , var2"
var0 : \n call [esp]
var0 :
var0 :
"mov eax , 106"
"mov eax , 106"
decoder :
decoder :
main :
decoder :
"var0 : \n pop var1 \n mov var1 , [esi]"
var0 : \n pop var1 \n pop var1
"decoder : \n pop var0 \n mov var1 , var0"
var0 : \n call [esp]
var0 : db var1
var0 : db var1
db var0
var0 : db var0
"db var0 , 0x00"
var0 : db var1
var0 : db var1
var0 : db var1
var0 : db var1
var0 : db var1
var0 :
var0 : \n jmp short esp
var0 :
formatting :
"mov eax , 106"
global var0
global _start
inc var0
inc var0 \n inc var0 \n inc var0 \n inc var0 \n inc var0
inc var0 \n inc var0 \n inc var0 \n inc var0 \n inc var0
inc var0 \n inc var0 \n inc var0 \n inc var0 \n inc var0
inc var0 \n inc var0 \n inc var0 \n inc var0 \n inc var0
inc var0 \n inc var0 \n inc var0 \n inc var0 \n inc var0
inc var0
inc var0 \n inc var0 \n inc var0 \n inc var0 \n inc var0
inc var0 \n inc var0 \n inc var0 \n inc var0 \n inc var0
inc var0 \n inc var0 \n inc var0 \n inc var0 \n inc var0
inc esi \n inc esi \n inc esi
inc esi \n inc esi \n inc esi
inc var0 \n inc var0 \n inc var0 \n inc var0 \n inc var0
inc var0 \n inc var0 \n inc var0 \n inc var0 \n inc var0
inc esi \n inc esi \n inc esi \n inc esi
inc esi \n inc esi \n jmp short decode
var0 :
jmp decode
jmp short var0
"mov eax , 106"
jmp short var0
jmp short cycle
jmp short decode
jmp short decode
jmp back decode
var0 : \n inc var1 \n inc var1
jmp short var0
jmp short var0
jmp short main
"mov eax , 106"
jmp short switch
jz var0
"lea edi , [var0]"
"lea var1 , [var0]"
"lea var1 , [var0]"
"lea var0 , [esi]"
"lea var1 , [var0]"
"lea var1 , [var0]"
"lea edi , [var0]"
loopnz var0 \n jmp short shellcode
loop decode
loop decode \n jmp var0
loop decode \n jmp short var2
loop decode \n jmp short shellcode
loop var0 \n jmp shellcode
loop decode \n jmp short var0
loop decode \n jmp short shellcode
loop var1 \n jmp var2
var0 :
"mov eax , 106"
"mov var0 , al"
"mov var0 , al"
"xchg al , var0"
"mov al , byte var0"
"lea al , byte [var0]"
"mov al , byte var0"
"mov al , cl"
"mov al , dl"
"mov al , dl"
"mov ax , [var0]"
"mov ax , [var1]"
"mov bh , var0"
"mov bh , byte var0"
"mov var0 , byte [esi]"
"mov var1 , var0"
"mov var1 , var0"
"mov var1 , byte [var0]"
"mov var1 , byte [var0]"
"mov var1 , byte [var0]"
"mov var1 , byte [var0]"
"mov var1 , byte [var0]"
"mov var1 , byte [var0]"
push byte var0 \n pop var1
"mov var1 , byte [var0]"
"mov var1 , byte [var0]"
"mov var1 , byte var0"
"mov bl , byte [esi+ecx+1]"
"mov var0 , cl"
"mov var1 , [var0]"
"mov var0 , dl"
"mov var1 , var0"
"mov byte [var1] , var0 \n not byte [var1]"
"mov byte [var1] , var0 \n xor byte [var1] , var0"
"mov byte [var1] , var0"
"mov byte [esi] , dl"
"mov byte [var1] , var0"
"mov var0 , dl"
"mov byte [var1] , var0"
"mov [var0] , cl"
"mov byte [esp] , bh"
"mov byte [esp] , var0"
"mov byte [esp] , var0"
"mov byte [var1] , var0"
push byte var0 \n pop var1
"mov byte [var0] , 10"
"mov cl , 13"
"mov cl , al"
"mov cl , byte var0"
"mov cl , byte [var0]"
"mov cl , dl"
"mov dl , var0"
"mov dl , byte [esi]"
"mov [var0] , dl"
"mov dl , var0"
"mov dl , var0"
"mov dl , byte var0"
"mov dl , byte var0"
"mov dl , [var0]"
"mov dl , byte var0"
push byte var0 \n pop dl
"mov var1 , var0"
"mov var1 , var0"
"mov var1 , var0"
"mov var0 , [esi]"
"mov var0 , esp"
"mov var0 , ax"
var0 : \n not dl \n inc dl
var0 : inc var1 \n jmp short formatting
not byte [var0]
var0 :
"mov eax , 106"
var0 :
pop var0
pop var0
pop var0
pop var0
"pop var0 \n mov cx , [var0]"
push encoded shellcode
"push var0 \n mov var1 , [var0]"
var0 :
"rol shellcode , 1"
"ror var0 , cl"
"rol var0 , 1"
section . text
var0 : equ $-shellcode
var0 : \n call [esp]
shellcode : db var0
shellcode : db var0
shellcode : bytes var0
array db var0
shellcode : db var0
shellcode [var0]
shellcode [var0]
db var0
shellcode : db var0
var0 :
"shl var0 , 28"
"shl var0 , 28"
"shr ax , 1"
"shr ax , cl \n not word ax"
"shr var0 , 4"
"shr dl , 1"
"shr dl , 4"
"shr var0 , 24"
"shr var0 , 28"
stage :
"sub ax , 13"
"sub var0 , al"
"sub byte [esi] , var0"
"sub byte [var0] , 8 \n not byte [var0]"
"sub cl , dl"
"sub dl , al \n jns var0"
"sub var1 , var0"
"sub var0 , var0"
"sub esp , var0"
var0 :
jmp var0
"xchg al , next byte"
"xor al , var0 \n jz short shellcode"
"xor ax , var0"
"xor ax , var0"
"xor ax , var0 \n jnz call decoded"
"xor bh , byte [esi+edx]"
"xor var0 , var0 \n jnz var2"
"xor var0 , var0 \n jnz encoded"
"xor var0 , var1 \n jnz formatting \n mov cl , byte [esi]"
"xor var0 , byte [esi+edx]"
"xor var0 , dl \n jnz short shellcode"
"xor byte [var0] , var1"
"xor byte [var0] , var1"
"xor byte [esi] , dl"
"xor byte [var0] , dl"
"xor byte [var0] , dl"
"xor [esi+1] , dl"
"xor var0 , byte [esi+edx]"
"xor cl , var0 \n jnz short var1"
"xor cl , var0 \n jnz var2"
"xor cl , var0 \n jnz shift decode"
"xor cl , byte [esi+edx]"
"xor dl , var0 \n jnz var2"
"xor var0 , var0 \n mov dl , var1"
"xor var0 , var0 \n mov al , 22"
"xor var0 , var0 \n xor var1 , var1"
"xor var0 , var0 \n xor var1 , var1 \n xor var2 , var2"
"xor var0 , var0 \n xor var1 , var1 \n xor var2 , var2 \n xor var3 , var3"
"xor var0 , var0 \n xor var1 , var1 \n xor var2 , var2 \n xor var3 , var3"
"xor var0 , var0"
"xor var0 , var0"
"xor var0 , var0 \n mov bl , [esi+1]"
"xor var0 , var0 \n xor var1 , var1"
"xor var0 , var0"
"xor var0 , var0 \n mov bl , var1"
"xor var0 , var0 \n mov dl , [esi+1]"
"xor var0 , var0 \n mov al , 23"
"xor var0 , var0 \n mov al , 25"
"xor loop , loop \n mov var0 , [esi+1]"
"xor var0 , var0 \n xor var1 , var1"
"xor var0 , var0 \n xor var1 , var1"
"xor var1 , var1 \n mul var1"
"xor var0 , var0 \n xor var1 , var1"
"xor var0 , var0 \n xor var1 , var1 \n xor var2 , var2 \n xor var3 , var3"
"xor var0 , var0 \n mov bl , [esi+1]"
var0 :
